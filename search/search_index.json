{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Hi</p>"},{"location":"devops/Correlating%20Bamboo%20Concepts%20with%20AWS%20ECS/","title":"Correlating Bamboo Concepts with AWS ECS","text":"<p>When managing CI/CD pipelines with Atlassian Bamboo and deploying containerized workloads using AWS Elastic Container Service (ECS), understanding how their concepts align can help streamline workflows. This post explores how Bamboo and ECS can complement each other, enabling parallel usage for seamless integration of CI/CD and container orchestration.</p>"},{"location":"devops/Correlating%20Bamboo%20Concepts%20with%20AWS%20ECS/#atlassian-bamboo-concepts","title":"Atlassian Bamboo Concepts","text":"<ol> <li> <p>Project    A project in Bamboo is a logical grouping of plans, representing a high-level entity such as an application, service, or product.    Example: For a \"Payment System,\" the project might include multiple plans for backend, frontend, and database components.</p> </li> <li> <p>Plan    A plan is a sequence of jobs that define how your code is built, tested, and packaged. This forms the foundation of Bamboo\u2019s CI pipeline.    Example: A backend plan could involve steps to compile Java code, run unit tests, and package it into a JAR file.</p> </li> <li> <p>Deployment    Deployment in Bamboo refers to delivering an application or artifact (produced by a plan) to a specific environment, such as development, staging, or production.    Example: A deployment plan outlines the steps for deploying the application to a staging environment, including configuration changes.</p> </li> <li> <p>Release    A release is a versioned snapshot of your software, ready for deployment. It represents a stable build after passing tests.    Example: Version <code>1.0.0</code> of your application is tagged as a release and marked as ready for production.</p> </li> </ol>"},{"location":"devops/Correlating%20Bamboo%20Concepts%20with%20AWS%20ECS/#mapping-bamboo-concepts-to-aws-ecs-for-parallel-usage","title":"Mapping Bamboo Concepts to AWS ECS for Parallel Usage","text":"<p>While Bamboo manages CI/CD workflows, AWS ECS focuses on container orchestration. These tools can work together, with Bamboo feeding ECS through seamless CI/CD pipelines. Here's how their concepts align:</p> <ol> <li> <p>Project \u2192 ECS Cluster or Application Group    A Bamboo project can correspond to an ECS cluster or a grouping of services within your infrastructure.    Example: The \"Payment System\" project in Bamboo maps to an ECS cluster hosting multiple services.</p> </li> <li> <p>Plan \u2192 ECS Task Definition    Bamboo plans can handle the CI pipeline for building and packaging Docker containers, which are then referenced in ECS task definitions.    Example: A Bamboo plan builds a Docker container and pushes it to Amazon ECR, ready for deployment in ECS.</p> </li> <li> <p>Deployment \u2192 ECS Service Update    Bamboo deployments can trigger ECS service updates, rolling out new versions of containers to specific environments like staging or production.    Example: A Bamboo deployment task updates the ECS service with a new task definition.</p> </li> <li> <p>Release \u2192 Docker Image Version or Task Definition Revision    Bamboo releases can represent versioned Docker images or ECS task definition revisions, providing stability and consistency.    Example: A release like <code>payment-backend:1.0.0</code> is tagged in Bamboo and used as a task definition in ECS.</p> </li> </ol>"},{"location":"devops/Correlating%20Bamboo%20Concepts%20with%20AWS%20ECS/#configuring-bamboo-plans-using-iac-with-java","title":"Configuring Bamboo Plans Using IaC with Java","text":"<p>Bamboo allows plans to be defined and managed programmatically using Infrastructure as Code (IaC). This approach ensures consistency, repeatability, and easier integration with version control systems. As of now, Atlassian Bamboo supports Java (via the Bamboo Specs API) and YAML (for declarative configurations).</p>"},{"location":"devops/Correlating%20Bamboo%20Concepts%20with%20AWS%20ECS/#example-defining-a-bamboo-plan-with-java","title":"Example: Defining a Bamboo Plan with Java","text":"<pre><code>// Initialize Bamboo Server\nBambooServer bambooServer = new BambooServer(\"https://your-bamboo-server.com\");\n\n// Create the Bamboo Plan\nPlan plan = new Plan(\n    new Project().key(\"DOCKER\").name(\"Docker Project\"),\n    \"Docker Image Build Plan\",\n    \"DIB\")\n    .description(\"Plan to build Docker images for ECS deployment\")\n    .stages(\n        new Stage(\"Build Stage\")\n            .jobs(new Job(\"Build and Dockerize Job\", \"BUILD\")\n                .tasks(\n                    // Step 1: Checkout the source code\n                    new VcsCheckoutTask()\n                        .description(\"Checkout Code\")\n                        .checkoutItems(new CheckoutItem().repository(\"MyRepo\")),\n\n                    // Step 2: Build the application (e.g., Maven build)\n                    new ScriptTask()\n                        .description(\"Build Application\")\n                        .inlineBody(\"mvn clean install\"),\n\n                    // Step 3: Build the Docker image\n                    new DockerBuildImageTask()\n                        .description(\"Build Docker Image\")\n                        .imageName(\"my-ecr-repo/my-app:latest\")\n                        .dockerfileInWorkingDir()\n                )\n            )\n    );\n\n// Publish the plan to Bamboo\nbambooServer.publish(plan);\n\nSystem.out.println(\"Plan published successfully!\");\n</code></pre>"},{"location":"devops/Correlating%20Bamboo%20Concepts%20with%20AWS%20ECS/#choosing-between-java-and-yaml","title":"Choosing Between Java and YAML","text":"Feature Java YAML Complexity Suitable for complex configurations Ideal for simple and straightforward setups Flexibility Highly flexible, supports logic and dynamic plans Limited to static declarative configurations Ease of Use Requires Java knowledge and tools Easy for non-developers to use Tooling IDE support, type checking Plain text editor is sufficient <p>For most teams, YAML is easier for basic use cases, while Java offers the power and flexibility needed for advanced configurations. This approach complements AWS ECS, where you can similarly define infrastructure using tools like AWS CloudFormation or Terraform, enabling end-to-end IaC workflows.</p>"},{"location":"devops/Correlating%20Bamboo%20Concepts%20with%20AWS%20ECS/#conclusion","title":"Conclusion","text":"<p>Using Bamboo and AWS ECS in parallel leverages the strengths of both platforms: Bamboo\u2019s robust CI/CD pipelines and ECS\u2019s efficient container orchestration. Adding IaC capabilities to Bamboo plans using Java enhances automation, consistency, and collaboration. Together, these tools empower teams to streamline workflows, scale workloads, and maintain reliable deployments across diverse environments.</p> <p>Happy coding! \ud83d\udcbb</p>"},{"location":"java/How%20HashMap%20Handles%20Collisions/","title":"How HashMap Handles Collisions","text":"<p>Collisions in a <code>HashMap</code> occur when multiple keys hash to the same bucket index. This situation arises because different keys can produce the same hash value. To handle such cases, <code>HashMap</code> employs separate chaining, where it stores multiple key-value pairs in a bucket using a linked list (or a balanced tree for performance optimization, starting from Java 8).</p> <p>Let\u2019s dive into an example to understand how this works.</p>"},{"location":"java/How%20HashMap%20Handles%20Collisions/#the-code-simulating-collisions","title":"The Code: Simulating Collisions","text":"<p>The following example demonstrates what happens when multiple keys in a <code>HashMap</code> collide due to having the same hash code:</p> <pre><code>import java.util.HashMap;\n\npublic class HashMapCollisionExample {\n    public static void main(String[] args) {\n\n       var map = new HashMap&lt;KeyWithSameHash, String&gt;();\n       map.put(new KeyWithSameHash(\"Key1\"), \"Value1\");\n       map.put(new KeyWithSameHash(\"Key2\"), \"Value2\");\n       map.put(new KeyWithSameHash(\"Key3\"), \"Value3\");\n\n       // prints Value3\n       System.out.println(map.get(new KeyWithSameHash(\"Key3\")));\n    }\n}\n\nclass KeyWithSameHash {\n    private String key;\n\n    public KeyWithSameHash(String key) {\n        this.key = key;\n    }\n\n    @Override\n    public int hashCode() {\n        return 1001; // Causes all keys to hash to the same bucket\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        KeyWithSameHash other = (KeyWithSameHash) obj;\n        return key.equals(other.key);\n    }\n\n    @Override\n    public String toString() {\n        return key;\n    }\n}\n</code></pre>"},{"location":"java/How%20HashMap%20Handles%20Collisions/#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":"<ol> <li> <p>Hash Code Calculation    When you call <code>map.put(new KeyWithSameHash(\"Key3\"), \"Value3\")</code>, the <code>hashCode()</code> method of the key returns <code>1001</code> for all instances, forcing all keys to map to the same bucket.</p> </li> <li> <p>Bucket Index Determination    Although the hash code is <code>1001</code>, the bucket index is calculated using a bitwise operation (<code>hashCode % bucketArrayLength</code>), ensuring entries are distributed across available buckets. However, in this case, all keys land in the same bucket because their hash codes are identical.</p> </li> <li> <p>Collision Handling    Since multiple keys are mapped to the same bucket, <code>HashMap</code> handles the collision using a linked list (or balanced tree). Each entry in the bucket is stored as a node in the list.</p> </li> <li> <p>Key Lookup    When you retrieve a value using a key (e.g., <code>new KeyWithSameHash(\"Key3\")</code>), the <code>HashMap</code>:</p> <ul> <li>Finds the bucket for the key.</li> <li>Traverses the linked list in that bucket.</li> <li>Compares each key in the list using the <code>equals()</code> method until it finds a match.</li> </ul> </li> <li> <p>Value Retrieval    Once the key is located (where <code>equals()</code> returns <code>true</code>), the corresponding value is returned.</p> </li> </ol>"},{"location":"java/How%20HashMap%20Handles%20Collisions/#retrieval-complexity","title":"Retrieval Complexity","text":"<p>Despite all keys having the same hash code, the <code>HashMap</code> successfully retrieves the correct value due to its <code>equals()</code> comparison mechanism. However, retrieval complexity can degrade to (O(n)) if all keys hash to the same bucket and the bucket uses a linked list, or to (O(log n)) if the bucket uses a balanced tree (introduced in Java 8).</p>"},{"location":"java/How%20HashMap%20Handles%20Collisions/#wrap-up","title":"Wrap Up","text":"<ol> <li>Efficient Collision Handling: <code>HashMap</code> can handle collisions gracefully using separate chaining, ensuring reliable behavior even when hash codes collide.</li> <li>Importance of Proper <code>hashCode</code> Implementation: A poor hash code implementation, as shown in this example, can lead to performance degradation since all keys fall into the same bucket.</li> <li>Balanced Trees for Performance: Starting with Java 8, <code>HashMap</code> replaces the linked list with a balanced tree when collisions exceed a threshold, improving lookup times in heavily collided buckets.</li> </ol> <p>Happy coding! \ud83d\udcbb</p>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/","title":"How Singleton Components Work with Thread Pools","text":"<p>Spring\u2019s component model is built on the principle of singletons for many of its core beans, ensuring efficiency and consistency across your application. If you\u2019ve ever wondered how Spring handles multiple requests while maintaining a single instance for components like controllers, services, and repositories, this article will walk you through it with practical examples and insights.</p> <ul> <li>Source code : Singleton Components Demo</li> </ul>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#what-are-singletons-in-spring","title":"What are Singletons in Spring?","text":"<p>In Spring, the default scope of beans is <code>singleton</code>, which means Spring creates exactly one instance of a bean per application context. This single instance is shared across all requests, ensuring consistency and reducing overhead.</p> <p>To verify that components like controllers, services, and repositories are singletons, you can use <code>System.identityHashCode</code> to print the unique memory reference hash for each bean instance.</p>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#verifying-singleton-behavior-with-code","title":"Verifying Singleton Behavior with Code","text":"<p>Let\u2019s take a look at a simple Spring Boot application to demonstrate this.</p>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#1-order-entity","title":"1. Order Entity","text":"<p>This entity represents a basic <code>Order</code> object stored in a database:</p> <pre><code>@Entity\n@Table(name = \"orders\")\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Order {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n    private String description;\n}\n</code></pre>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#2-order-controller","title":"2. Order Controller","text":"<p>The controller exposes an endpoint to fetch all orders and logs its hash code to verify its singleton nature:</p> <pre><code>@RestController\n@RequestMapping(\"/api/orders\")\n@RequiredArgsConstructor\n@Slf4j\npublic class OrderController {\n\n    private final OrderService orderService;\n\n    @GetMapping\n    public ResponseEntity&lt;List&lt;OrderDTO&gt;&gt; findAll() {\n        log.info(\"OrderController HashCode: {}\", System.identityHashCode(this));\n\n        var response = orderService.findAll()\n                .stream()\n                .map(order -&gt; new OrderDTO(order.getName(), order.getDescription()))\n                .toList();\n        return ResponseEntity.status(HttpStatus.OK).body(response);\n    }\n}\n</code></pre>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#3-order-service","title":"3. Order Service","text":"<p>The service layer handles business logic and also logs its hash code, along with the repository's:</p> <pre><code>@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class OrderService {\n\n    private final OrderRepository orderRepository;\n\n    public List&lt;Order&gt; findAll() {\n        log.info(\"OrderService HashCode: {}\", System.identityHashCode(this));\n        log.info(\"OrderRepository HashCode: {}\", System.identityHashCode(orderRepository));\n\n        return orderRepository.findAll();\n    }\n}\n</code></pre>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#observing-singleton-behavior-in-logs","title":"Observing Singleton Behavior in Logs","text":"<p>When you run the application and make multiple requests to <code>/api/orders</code>, the logs will show the same hash code for each instance. In my case, the hash codes were:</p> <pre><code>OrderController HashCode: 12345678\nOrderService HashCode: 87654321\nOrderRepository HashCode: 23456789\n</code></pre> <p>These consistent hash codes confirm that Spring is using the same instance of each bean across all requests.</p>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#how-spring-handles-concurrent-requests-with-thread-pools","title":"How Spring Handles Concurrent Requests with Thread Pools","text":"<p>You might wonder: if these components are singletons, how does Spring handle multiple requests concurrently?</p> <p>The answer lies in thread pools. Spring\u2019s default thread pool (backed by the servlet container, such as Tomcat) assigns each incoming HTTP request to a separate thread. Each thread executes the same singleton instance of your controller, service, and repository, ensuring that multiple requests can be processed concurrently.</p>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#key-points","title":"Key Points:","text":"<ul> <li>The singleton components themselves are not thread-safe by design, but the stateless nature of most services and repositories makes them safe for multi-threaded access.</li> <li>If your service or controller maintains state (e.g., using class-level variables), you must ensure thread safety manually, as multiple threads can access the same singleton instance simultaneously.</li> </ul>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#why-use-singletons","title":"Why Use Singletons?","text":"<ol> <li>Efficiency: Singletons reduce memory usage and initialization overhead since only one instance is created.</li> <li>Consistency: Using a single instance ensures that the state and configuration are consistent throughout the application.</li> </ol>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#wrap-up","title":"Wrap Up","text":"<p>Singletons, when combined with thread pools, allow Spring applications to scale efficiently without creating multiple instances of components. By logging <code>System.identityHashCode</code>, we verified that Spring uses the same instance of our beans across all requests. However, always remember to keep your singleton components stateless to avoid threading issues in multi-threaded environments.</p> <p>Happy coding! \ud83d\udcbb</p>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/","title":"Method-Level Authorization in Spring Security","text":"<p>In this post, we'll explore how to use Spring Security to control access both at  the endpoint and method level using a sample project.  We'll cover role-based and authority-based security, showing how both can be configured  and used to enhance your application's overall security posture.</p> <ul> <li>Source code : Spring Security Method-Level Authorization Demo</li> </ul>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/#spring-security-configuration","title":"Spring Security Configuration","text":"<p>To get started, we need to configure Spring Security. Below is the <code>SecurityConfig</code> class, which is responsible for setting up the security rules and ensuring proper authentication and authorization for our application. With Spring Security, you can create custom security policies that help protect your application from unauthorized access.</p> <pre><code>@Bean\npublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n    http\n            .csrf(AbstractHttpConfigurer::disable)\n            .authorizeHttpRequests(auth -&gt; auth\n                    .requestMatchers(\"/public/**\").permitAll() // Allow access to public endpoints\n                    .requestMatchers(\"/admin/api/**\").hasRole(\"ADMIN\") // Require ADMIN role for admin endpoints\n                    .requestMatchers(\"/api/**\").hasRole(\"USER\") // Require USER role for general endpoints\n                    .anyRequest().authenticated()\n            )\n            .httpBasic(Customizer.withDefaults());\n\n    return http.build();\n}\n</code></pre> <p>The <code>SecurityFilterChain</code> bean is responsible for defining how requests are secured. We start by disabling CSRF protection for simplicity (note that in production, you should consider enabling it for non-API requests). Spring evaluates the matchers in the order they are defined in the authorizeHttpRequests block, stopping at the first match. This means that if multiple matchers overlap or are too generic, the earlier ones will take precedence, potentially overriding more restrictive rules.</p> <p>This layered approach to authorization allows us to provide clear boundaries for different types of users within our application, ensuring that each user only has access to the features they need.</p> <pre><code>@Bean\npublic UserDetailsService userDetailsService() {\n    var user1 = User.withUsername(\"user1\")\n            .password(\"{noop}user1\")\n            .roles(\"USER\")\n            .build();\n\n    var admin1 = User.withUsername(\"admin1\")\n            .password(\"{noop}admin1\")\n            .roles(\"ADMIN\")\n            .build();\n\n    var admin2 = User.withUsername(\"admin2\")\n            .password(\"{noop}admin2\")\n            .authorities(\"ROLE_ADMIN\", \"CREATE_ORDER\")\n            .build();\n\n    return new InMemoryUserDetailsManager(user1, admin1, admin2);\n}\n</code></pre> <p>In this configuration, we set up an <code>InMemoryUserDetailsManager</code> with three users: <code>user1</code>, <code>admin1</code>, and <code>admin2</code>. The user <code>user1</code> has the role <code>USER</code>, while <code>admin1</code> has the role <code>ADMIN</code>. Additionally, <code>admin2</code> has both the <code>ADMIN</code> role and an extra authority called <code>CREATE_ORDER</code>, which allows them to perform more specific actions, such as creating orders.</p> <p>In addition to HTTP Basic authentication, this configuration can easily be extended to include OAuth2 or JWT-based authentication to provide more sophisticated security mechanisms. </p>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/#applying-method-level-authorization","title":"Applying Method-Level Authorization","text":"<p>To illustrate how to implement method-level authorization, we have two controllers in our project: </p> <ul> <li>The <code>AdminController</code> handles administrative operations related to orders, while </li> <li>the general <code>Controller</code> manages regular user orders. </li> </ul> <p>By having separate controllers for different roles, we ensure that the application follows the principle of least privilege, where users only access the data they need.</p> <pre><code>@RestController\n@RequestMapping(\"/admin/api/orders\")\npublic class AdminController {\n\n    @GetMapping\n    public String getOrders() {\n        return \"Admin orders returned\";\n    }\n\n    @PostMapping\n    @PreAuthorize(\"hasAuthority('CREATE_ORDER')\")\n    public String createOrder() {\n        return \"Order created\";\n    }\n}\n</code></pre> <p>In the <code>AdminController</code>, there are two endpoints. The <code>GET</code> endpoint returns a list of orders, while the <code>POST</code> endpoint is used to create a new order. The <code>POST</code> endpoint is protected using the <code>@PreAuthorize</code> annotation to ensure that only users with the <code>CREATE_ORDER</code> authority can access it.</p> <p>The <code>@PreAuthorize</code> annotation is a powerful feature provided by Spring Security that allows you to specify authorization requirements at the method level. In this case, only users with the <code>CREATE_ORDER</code> authority are allowed to create a new order. This allows us to provide more granular control over access, ensuring that sensitive actions are restricted to users with the appropriate permissions.</p> <pre><code>@RestController\n@RequestMapping(\"/api/orders\")\npublic class Controller {\n\n    @GetMapping\n    public String getOrders() {\n        return \"Orders returned\";\n    }\n}\n</code></pre> <p>The general <code>Controller</code> is used for managing orders accessible to regular users. This controller does not have any special method-level security annotations, as it is intended for users with the <code>USER</code> role. </p>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/#response-examples-for-endpoint-requests","title":"Response Examples for Endpoint Requests","text":"<p>Here are some examples of the responses for different requests made to the API endpoints:</p> <pre><code>GET localhost:8080/api/orders\n\nHTTP 401 Unauthorized\n{\n  \"error\": \"Unauthorized\",\n  \"message\": \"Full authentication is required to access this resource\"\n}\n</code></pre> <pre><code>GET localhost:8080/api/orders\nAuthorization: Basic user1 user1\n\nHTTP 200 OK\nOrders returned\n</code></pre> <pre><code>GET localhost:8080/admin/api/orders\nAuthorization: Basic admin1 admin1\n\nHTTP 200 OK\nAdmin orders returned\n</code></pre> <pre><code>POST localhost:8080/admin/api/orders\nAuthorization: Basic admin1 admin1\n\nHTTP 403 Forbidden\n{\n  \"error\": \"Forbidden\",\n  \"message\": \"Access is denied\"\n}\n</code></pre> <pre><code>POST localhost:8080/admin/api/orders\nAuthorization: Basic admin2 admin2\n\nHTTP 200 OK\nOrder created\n</code></pre>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/#roles-vs-authorities","title":"Roles vs Authorities","text":"<p>Roles are a specific type of authority in Spring Security, distinguished by the <code>\"ROLE_\"</code> prefix in their names. For example, <code>.roles(\"ADMIN\")</code> is equivalent to <code>.authorities(\"ROLE_ADMIN\")</code>.</p> <p>However, caution is needed when mixing <code>roles</code> and <code>authorities</code> while configuring user permissions. In the example below, the user will have only the <code>CREATE_ORDER</code> authority because <code>.authorities(\"CREATE_ORDER\")</code> overrides <code>.roles(\"ADMIN\")</code>.</p> <pre><code>var admin = User.withUsername(\"admin\")\n    .password(\"{noop}admin\")\n    .roles(\"ADMIN\") // This is translated to \"ROLE_ADMIN\"\n    .authorities(\"CREATE_ORDER\") // This overrides the role\n    .build();\n</code></pre> <p>In such cases, explicitly specify all desired authorities in <code>.authorities()</code> to avoid unintentional overrides.</p>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/#additional-considerations-for-method-level-security","title":"Additional Considerations for Method-Level Security","text":"<p>Additionally, method-level security annotations like <code>@PreAuthorize</code> can be combined with other annotations such as <code>@PostAuthorize</code>, <code>@Secured</code>, and <code>@RolesAllowed</code> to provide even more flexibility. For instance, <code>@PostAuthorize</code> can be used to validate the response after the method has executed, which can be helpful in certain scenarios, such as ensuring that a user only sees data they are allowed to access.</p> <p>Happy coding! \ud83d\udcbb</p>"}]}
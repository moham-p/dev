{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Hi</p>"},{"location":"java/How%20HashMap%20Handles%20Collisions/","title":"How HashMap Handles Collisions","text":"<p>Collisions in a <code>HashMap</code> occur when multiple keys hash to the same bucket index. This situation arises because different keys can produce the same hash value. To handle such cases, <code>HashMap</code> employs separate chaining, where it stores multiple key-value pairs in a bucket using a linked list (or a balanced tree for performance optimization, starting from Java 8).</p> <p>Let\u2019s dive into an example to understand how this works.</p>"},{"location":"java/How%20HashMap%20Handles%20Collisions/#the-code-simulating-collisions","title":"The Code: Simulating Collisions","text":"<p>The following example demonstrates what happens when multiple keys in a <code>HashMap</code> collide due to having the same hash code:</p> <pre><code>import java.util.HashMap;\n\npublic class HashMapCollisionExample {\n    public static void main(String[] args) {\n\n       var map = new HashMap&lt;KeyWithSameHash, String&gt;();\n       map.put(new KeyWithSameHash(\"Key1\"), \"Value1\");\n       map.put(new KeyWithSameHash(\"Key2\"), \"Value2\");\n       map.put(new KeyWithSameHash(\"Key3\"), \"Value3\");\n\n       // prints Value3\n       System.out.println(map.get(new KeyWithSameHash(\"Key3\")));\n    }\n}\n\nclass KeyWithSameHash {\n    private String key;\n\n    public KeyWithSameHash(String key) {\n        this.key = key;\n    }\n\n    @Override\n    public int hashCode() {\n        return 1001; // Causes all keys to hash to the same bucket\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        KeyWithSameHash other = (KeyWithSameHash) obj;\n        return key.equals(other.key);\n    }\n\n    @Override\n    public String toString() {\n        return key;\n    }\n}\n</code></pre>"},{"location":"java/How%20HashMap%20Handles%20Collisions/#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":"<ol> <li> <p>Hash Code Calculation    When you call <code>map.put(new KeyWithSameHash(\"Key3\"), \"Value3\")</code>, the <code>hashCode()</code> method of the key returns <code>1001</code> for all instances, forcing all keys to map to the same bucket.</p> </li> <li> <p>Bucket Index Determination    Although the hash code is <code>1001</code>, the bucket index is calculated using a bitwise operation (<code>hashCode % bucketArrayLength</code>), ensuring entries are distributed across available buckets. However, in this case, all keys land in the same bucket because their hash codes are identical.</p> </li> <li> <p>Collision Handling    Since multiple keys are mapped to the same bucket, <code>HashMap</code> handles the collision using a linked list (or balanced tree). Each entry in the bucket is stored as a node in the list.</p> </li> <li> <p>Key Lookup    When you retrieve a value using a key (e.g., <code>new KeyWithSameHash(\"Key3\")</code>), the <code>HashMap</code>:</p> <ul> <li>Finds the bucket for the key.</li> <li>Traverses the linked list in that bucket.</li> <li>Compares each key in the list using the <code>equals()</code> method until it finds a match.</li> </ul> </li> <li> <p>Value Retrieval    Once the key is located (where <code>equals()</code> returns <code>true</code>), the corresponding value is returned.</p> </li> </ol>"},{"location":"java/How%20HashMap%20Handles%20Collisions/#retrieval-complexity","title":"Retrieval Complexity","text":"<p>Despite all keys having the same hash code, the <code>HashMap</code> successfully retrieves the correct value due to its <code>equals()</code> comparison mechanism. However, retrieval complexity can degrade to (O(n)) if all keys hash to the same bucket and the bucket uses a linked list, or to (O(log n)) if the bucket uses a balanced tree (introduced in Java 8).</p>"},{"location":"java/How%20HashMap%20Handles%20Collisions/#wrap-up","title":"Wrap Up","text":"<ol> <li>Efficient Collision Handling: <code>HashMap</code> can handle collisions gracefully using separate chaining, ensuring reliable behavior even when hash codes collide.</li> <li>Importance of Proper <code>hashCode</code> Implementation: A poor hash code implementation, as shown in this example, can lead to performance degradation since all keys fall into the same bucket.</li> <li>Balanced Trees for Performance: Starting with Java 8, <code>HashMap</code> replaces the linked list with a balanced tree when collisions exceed a threshold, improving lookup times in heavily collided buckets.</li> </ol> <p>Happy coding! \ud83d\udcbb</p>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/","title":"How Singleton Components Work with Thread Pools","text":"<p>Spring\u2019s component model is built on the principle of singletons for many of its core beans, ensuring efficiency and consistency across your application. If you\u2019ve ever wondered how Spring handles multiple requests while maintaining a single instance for components like controllers, services, and repositories, this article will walk you through it with practical examples and insights.</p> <ul> <li>Source code : Singleton Components Demo</li> </ul>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#what-are-singletons-in-spring","title":"What are Singletons in Spring?","text":"<p>In Spring, the default scope of beans is <code>singleton</code>, which means Spring creates exactly one instance of a bean per application context. This single instance is shared across all requests, ensuring consistency and reducing overhead.</p> <p>To verify that components like controllers, services, and repositories are singletons, you can use <code>System.identityHashCode</code> to print the unique memory reference hash for each bean instance.</p>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#verifying-singleton-behavior-with-code","title":"Verifying Singleton Behavior with Code","text":"<p>Let\u2019s take a look at a simple Spring Boot application to demonstrate this.</p>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#1-order-entity","title":"1. Order Entity","text":"<p>This entity represents a basic <code>Order</code> object stored in a database:</p> <pre><code>@Entity\n@Table(name = \"orders\")\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Order {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n    private String description;\n}\n</code></pre>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#2-order-controller","title":"2. Order Controller","text":"<p>The controller exposes an endpoint to fetch all orders and logs its hash code to verify its singleton nature:</p> <pre><code>@RestController\n@RequestMapping(\"/api/orders\")\n@RequiredArgsConstructor\n@Slf4j\npublic class OrderController {\n\n    private final OrderService orderService;\n\n    @GetMapping\n    public ResponseEntity&lt;List&lt;OrderDTO&gt;&gt; findAll() {\n        log.info(\"OrderController HashCode: {}\", System.identityHashCode(this));\n\n        var response = orderService.findAll()\n                .stream()\n                .map(order -&gt; new OrderDTO(order.getName(), order.getDescription()))\n                .toList();\n        return ResponseEntity.status(HttpStatus.OK).body(response);\n    }\n}\n</code></pre>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#3-order-service","title":"3. Order Service","text":"<p>The service layer handles business logic and also logs its hash code, along with the repository's:</p> <pre><code>@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class OrderService {\n\n    private final OrderRepository orderRepository;\n\n    public List&lt;Order&gt; findAll() {\n        log.info(\"OrderService HashCode: {}\", System.identityHashCode(this));\n        log.info(\"OrderRepository HashCode: {}\", System.identityHashCode(orderRepository));\n\n        return orderRepository.findAll();\n    }\n}\n</code></pre>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#observing-singleton-behavior-in-logs","title":"Observing Singleton Behavior in Logs","text":"<p>When you run the application and make multiple requests to <code>/api/orders</code>, the logs will show the same hash code for each instance. In my case, the hash codes were:</p> <pre><code>OrderController HashCode: 12345678\nOrderService HashCode: 87654321\nOrderRepository HashCode: 23456789\n</code></pre> <p>These consistent hash codes confirm that Spring is using the same instance of each bean across all requests.</p>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#how-spring-handles-concurrent-requests-with-thread-pools","title":"How Spring Handles Concurrent Requests with Thread Pools","text":"<p>You might wonder: if these components are singletons, how does Spring handle multiple requests concurrently?</p> <p>The answer lies in thread pools. Spring\u2019s default thread pool (backed by the servlet container, such as Tomcat) assigns each incoming HTTP request to a separate thread. Each thread executes the same singleton instance of your controller, service, and repository, ensuring that multiple requests can be processed concurrently.</p>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#key-points","title":"Key Points:","text":"<ul> <li>The singleton components themselves are not thread-safe by design, but the stateless nature of most services and repositories makes them safe for multi-threaded access.</li> <li>If your service or controller maintains state (e.g., using class-level variables), you must ensure thread safety manually, as multiple threads can access the same singleton instance simultaneously.</li> </ul>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#why-use-singletons","title":"Why Use Singletons?","text":"<ol> <li>Efficiency: Singletons reduce memory usage and initialization overhead since only one instance is created.</li> <li>Consistency: Using a single instance ensures that the state and configuration are consistent throughout the application.</li> </ol>"},{"location":"spring/How%20Singleton%20Components%20Work%20with%20Thread%20Pools/#wrap-up","title":"Wrap Up","text":"<p>Singletons, when combined with thread pools, allow Spring applications to scale efficiently without creating multiple instances of components. By logging <code>System.identityHashCode</code>, we verified that Spring uses the same instance of our beans across all requests. However, always remember to keep your singleton components stateless to avoid threading issues in multi-threaded environments.</p> <p>Happy coding! \ud83d\udcbb</p>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/","title":"Method-Level Authorization in Spring Security","text":"<p>In this post, we'll explore how to use Spring Security to control access both at  the endpoint and method level using a sample project.  We'll cover role-based and authority-based security, showing how both can be configured  and used to enhance your application's overall security posture.</p> <ul> <li>Source code : Spring Security Method-Level Authorization Demo</li> </ul>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/#spring-security-configuration","title":"Spring Security Configuration","text":"<p>To get started, we need to configure Spring Security. Below is the <code>SecurityConfig</code> class, which is responsible for setting up the security rules and ensuring proper authentication and authorization for our application. With Spring Security, you can create custom security policies that help protect your application from unauthorized access.</p> <pre><code>@Bean\npublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n    http\n            .csrf(AbstractHttpConfigurer::disable)\n            .authorizeHttpRequests(auth -&gt; auth\n                    .requestMatchers(\"/public/**\").permitAll() // Allow access to public endpoints\n                    .requestMatchers(\"/admin/api/**\").hasRole(\"ADMIN\") // Require ADMIN role for admin endpoints\n                    .requestMatchers(\"/api/**\").hasRole(\"USER\") // Require USER role for general endpoints\n                    .anyRequest().authenticated()\n            )\n            .httpBasic(Customizer.withDefaults());\n\n    return http.build();\n}\n</code></pre> <p>The <code>SecurityFilterChain</code> bean is responsible for defining how requests are secured. We start by disabling CSRF protection for simplicity (note that in production, you should consider enabling it for non-API requests). Spring evaluates the matchers in the order they are defined in the authorizeHttpRequests block, stopping at the first match. This means that if multiple matchers overlap or are too generic, the earlier ones will take precedence, potentially overriding more restrictive rules.</p> <p>This layered approach to authorization allows us to provide clear boundaries for different types of users within our application, ensuring that each user only has access to the features they need.</p> <pre><code>@Bean\npublic UserDetailsService userDetailsService() {\n    var user1 = User.withUsername(\"user1\")\n            .password(\"{noop}user1\")\n            .roles(\"USER\")\n            .build();\n\n    var admin1 = User.withUsername(\"admin1\")\n            .password(\"{noop}admin1\")\n            .roles(\"ADMIN\")\n            .build();\n\n    var admin2 = User.withUsername(\"admin2\")\n            .password(\"{noop}admin2\")\n            .authorities(\"ROLE_ADMIN\", \"CREATE_ORDER\")\n            .build();\n\n    return new InMemoryUserDetailsManager(user1, admin1, admin2);\n}\n</code></pre> <p>In this configuration, we set up an <code>InMemoryUserDetailsManager</code> with three users: <code>user1</code>, <code>admin1</code>, and <code>admin2</code>. The user <code>user1</code> has the role <code>USER</code>, while <code>admin1</code> has the role <code>ADMIN</code>. Additionally, <code>admin2</code> has both the <code>ADMIN</code> role and an extra authority called <code>CREATE_ORDER</code>, which allows them to perform more specific actions, such as creating orders.</p> <p>In addition to HTTP Basic authentication, this configuration can easily be extended to include OAuth2 or JWT-based authentication to provide more sophisticated security mechanisms. </p>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/#applying-method-level-authorization","title":"Applying Method-Level Authorization","text":"<p>To illustrate how to implement method-level authorization, we have two controllers in our project: </p> <ul> <li>The <code>AdminController</code> handles administrative operations related to orders, while </li> <li>the general <code>Controller</code> manages regular user orders. </li> </ul> <p>By having separate controllers for different roles, we ensure that the application follows the principle of least privilege, where users only access the data they need.</p> <pre><code>@RestController\n@RequestMapping(\"/admin/api/orders\")\npublic class AdminController {\n\n    @GetMapping\n    public String getOrders() {\n        return \"Admin orders returned\";\n    }\n\n    @PostMapping\n    @PreAuthorize(\"hasAuthority('CREATE_ORDER')\")\n    public String createOrder() {\n        return \"Order created\";\n    }\n}\n</code></pre> <p>In the <code>AdminController</code>, there are two endpoints. The <code>GET</code> endpoint returns a list of orders, while the <code>POST</code> endpoint is used to create a new order. The <code>POST</code> endpoint is protected using the <code>@PreAuthorize</code> annotation to ensure that only users with the <code>CREATE_ORDER</code> authority can access it.</p> <p>The <code>@PreAuthorize</code> annotation is a powerful feature provided by Spring Security that allows you to specify authorization requirements at the method level. In this case, only users with the <code>CREATE_ORDER</code> authority are allowed to create a new order. This allows us to provide more granular control over access, ensuring that sensitive actions are restricted to users with the appropriate permissions.</p> <pre><code>@RestController\n@RequestMapping(\"/api/orders\")\npublic class Controller {\n\n    @GetMapping\n    public String getOrders() {\n        return \"Orders returned\";\n    }\n}\n</code></pre> <p>The general <code>Controller</code> is used for managing orders accessible to regular users. This controller does not have any special method-level security annotations, as it is intended for users with the <code>USER</code> role. </p>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/#response-examples-for-endpoint-requests","title":"Response Examples for Endpoint Requests","text":"<p>Here are some examples of the responses for different requests made to the API endpoints:</p> <pre><code>GET localhost:8080/api/orders\n\nHTTP 401 Unauthorized\n{\n  \"error\": \"Unauthorized\",\n  \"message\": \"Full authentication is required to access this resource\"\n}\n</code></pre> <pre><code>GET localhost:8080/api/orders\nAuthorization: Basic user1 user1\n\nHTTP 200 OK\nOrders returned\n</code></pre> <pre><code>GET localhost:8080/admin/api/orders\nAuthorization: Basic admin1 admin1\n\nHTTP 200 OK\nAdmin orders returned\n</code></pre> <pre><code>POST localhost:8080/admin/api/orders\nAuthorization: Basic admin1 admin1\n\nHTTP 403 Forbidden\n{\n  \"error\": \"Forbidden\",\n  \"message\": \"Access is denied\"\n}\n</code></pre> <pre><code>POST localhost:8080/admin/api/orders\nAuthorization: Basic admin2 admin2\n\nHTTP 200 OK\nOrder created\n</code></pre>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/#roles-vs-authorities","title":"Roles vs Authorities","text":"<p>Roles are a specific type of authority in Spring Security, distinguished by the <code>\"ROLE_\"</code> prefix in their names. For example, <code>.roles(\"ADMIN\")</code> is equivalent to <code>.authorities(\"ROLE_ADMIN\")</code>.</p> <p>However, caution is needed when mixing <code>roles</code> and <code>authorities</code> while configuring user permissions. In the example below, the user will have only the <code>CREATE_ORDER</code> authority because <code>.authorities(\"CREATE_ORDER\")</code> overrides <code>.roles(\"ADMIN\")</code>.</p> <pre><code>var admin = User.withUsername(\"admin\")\n    .password(\"{noop}admin\")\n    .roles(\"ADMIN\") // This is translated to \"ROLE_ADMIN\"\n    .authorities(\"CREATE_ORDER\") // This overrides the role\n    .build();\n</code></pre> <p>In such cases, explicitly specify all desired authorities in <code>.authorities()</code> to avoid unintentional overrides.</p>"},{"location":"spring/Method-Level%20Authorization%20in%20Spring%20Security/#additional-considerations-for-method-level-security","title":"Additional Considerations for Method-Level Security","text":"<p>Additionally, method-level security annotations like <code>@PreAuthorize</code> can be combined with other annotations such as <code>@PostAuthorize</code>, <code>@Secured</code>, and <code>@RolesAllowed</code> to provide even more flexibility. For instance, <code>@PostAuthorize</code> can be used to validate the response after the method has executed, which can be helpful in certain scenarios, such as ensuring that a user only sees data they are allowed to access.</p> <p>Happy coding! \ud83d\udcbb</p>"}]}